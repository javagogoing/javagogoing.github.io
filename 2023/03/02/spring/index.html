<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>spring | DaiBlogger</title><meta name="author" content="DaiBlogger"><meta name="copyright" content="DaiBlogger"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spring入门Spring入门什么是Spring框架？    Spring是一个分层的JavaSE&#x2F;EE full-stack(一站式) 轻量级开源的管理框架        分层            SUN提倡的三层结构:控制层、业务层、数据访问层（持久层，集成层）        一站式            Spring框架有对三层的每层都有自己的解决方案">
<meta property="og:type" content="article">
<meta property="og:title" content="spring">
<meta property="og:url" content="http://example.com/2023/03/02/spring/index.html">
<meta property="og:site_name" content="DaiBlogger">
<meta property="og:description" content="Spring入门Spring入门什么是Spring框架？    Spring是一个分层的JavaSE&#x2F;EE full-stack(一站式) 轻量级开源的管理框架        分层            SUN提倡的三层结构:控制层、业务层、数据访问层（持久层，集成层）        一站式            Spring框架有对三层的每层都有自己的解决方案">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/helloWorld.jpg">
<meta property="article:published_time" content="2023-03-02T07:19:10.000Z">
<meta property="article:modified_time" content="2023-03-06T06:15:21.726Z">
<meta property="article:author" content="DaiBlogger">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/helloWorld.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/03/02/spring/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'spring',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-06 14:15:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/helloWorld.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="DaiBlogger"><span class="site-name">DaiBlogger</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">spring</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-02T07:19:10.000Z" title="发表于 2023-03-02 15:19:10">2023-03-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-06T06:15:21.726Z" title="更新于 2023-03-06 14:15:21">2023-03-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="spring"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Spring入门"><a href="#Spring入门" class="headerlink" title="Spring入门"></a><strong><font color=#87CEFA>Spring入门</font></strong></h1><h2 id="Spring入门-1"><a href="#Spring入门-1" class="headerlink" title="Spring入门"></a><strong><font color=#87CEFA>Spring入门</font></strong></h2><p>什么是Spring框架？<br>    Spring是一个分层的JavaSE&#x2F;EE full-stack(一站式) 轻量级开源的管理框架<br>        分层<br>            SUN提倡的三层结构:控制层、业务层、数据访问层（持久层，集成层）<br>        一站式<br>            Spring框架有对三层的每层都有自己的解决方案<br>                控制层:Spring MVC<br>                持久层:JDBC Template<br>                业务层:Spring的事务管理、bean管理<br>        轻量级：小巧，使用方便<br>    总结<br>        spring是一个管理型框架，能整合众多著名的第三方框架、类库。在企业技术选型时，很多都会考虑选取的框架或技术和spring集成是否方便。</p>
<h2 id="Spring入门-2"><a href="#Spring入门-2" class="headerlink" title="Spring入门"></a><strong><font color=#87CEFA>Spring入门</font></strong></h2><p>Spring的作用(优点)？<br>    方便解耦，简化开发，Spring就是一个大工厂，可以将所有对象创建和依赖关系维护交给 Spring管理，避免硬编码所造成的过度耦合。<br>    AOP编程的支持 ，Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能<br>    声明式事务的支持，只需要通过配置就可以完成对事务的管理，而无需手动编程，提高开发效率和质量。<br>    方便程序的测试 ，Spring对 Junit4支持，可以通过注解方便的测试 Spring程序<br>    方便集成各种优秀框架 ，Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、 Quartz等）的直接支持<br>    降低 JavaEE API的使用难度 ，Spring 对 JavaEE开发中非常难用的一些 API（JDBC、JavaMail、远程调用等），都提供了封装，使这些 API 应用难度大大降低</p>
<h2 id="Spring入门-3"><a href="#Spring入门-3" class="headerlink" title="Spring入门"></a><strong><font color=#87CEFA>Spring入门</font></strong></h2><p>Spring 的核心<br>    IOC:（Inversesion of Control 反转控制）<br>        控制反转:将对象的创建权,交由Spring完成，不再是由我们自己编写代码去new<br>    AOP:Aspect Oriented Programming 面向切面编程 是面向对象的功能延伸。</p>
<h2 id="Spring中的IOC原理"><a href="#Spring中的IOC原理" class="headerlink" title="Spring中的IOC原理"></a><strong><font color=#87CEFA>Spring中的IOC原理</font></strong></h2><h3 id="传统开发中分层"><a href="#传统开发中分层" class="headerlink" title="传统开发中分层"></a><strong><font color=#87CEFA>传统开发中分层</font></strong></h3><p>控制层—&gt;业务层—&gt;持久层</p>
<h3 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a><strong><font color=#87CEFA>面向接口编程</font></strong></h3><p>以前业务层调用持久层的写法</p>
<pre><code>public class UserDAO&#123;
    public void add(User user) &#123;
        System.out.println(&quot;添加用户&quot;);
    &#125;
    
    public void delete(User user) &#123;
        System.out.println(&quot;删除用户&quot;);
    &#125;
​
    .....
&#125;
</code></pre>
<p>​<br>    public class UserService {<br>        &#x2F;&#x2F;不利于程序扩展和维护<br>        private UserDAO userDAO &#x3D; new UserDAO();</p>
<pre><code>    public void add(User user) &#123;
        userDAO.add(user);
    &#125;
    
    public void delete(User user) &#123;
        userDAO.delete(user);
    &#125;
    
    .....
&#125;
......
</code></pre>
<p>面向接口编程写法</p>
<pre><code>//dao层接口
public interface UserDAO &#123;
    public void add(User user);
    public void delete(User user);
    .....
&#125;
​
//dao层实现类
public class UserDAOImpl implements UserDAO&#123;
    public void add(User user) &#123;
        System.out.println(&quot;添加用户&quot;);
    &#125;
    public void delete(User user) &#123;
        System.out.println(&quot;删除用户&quot;);
    &#125;
​
    .....
&#125;
​
//业务层接口
public interface UserService &#123;
    
    public void add(User user);
​
    public void delete(User user);
    
    .....
&#125;
​
//业务层接口实现类
public class UserServiceImpl implements UserService &#123;
    
    private UserDAO userDAO = new UserDaoImpl();
    
    public void add(User user) &#123;
        userDAO.add(user);
    &#125;
​
    public void delete(User user) &#123;
        userDAO.delete(user);
    &#125;
​
    .....
&#125;
</code></pre>
<p>​<br>    &#x2F;&#x2F;测试:模拟控制层调用业务层<br>    public static void main(String[] agrs){<br>        UserService userService &#x3D; new UserServiceImpl();<br>        userService.add(new User());<br>    }</p>
<p>总结</p>
<pre><code>UserDao udao = new UserDaoImpl()----&gt;这种语法和List list = new ArrayList()类似。面向接口编程提高了程序的可扩展性、维护性和可复用性
</code></pre>
<h3 id="解耦合"><a href="#解耦合" class="headerlink" title="解耦合"></a><strong><font color=#87CEFA>解耦合</font></strong></h3><p>当然以上把对象的创建写死的方式private UserDAO userDAO &#x3D; new UserDaoImpl() 耦合度还是比较高的，因为如果要更改实现类，需要修改java代码</p>
<p>耦合高</p>
<pre><code>在开发中，对象之间的耦合度就指的是对象之间的依赖性。对象之间的耦合越高，维护成本越高，因此设计时应使类之间的耦合最小。
</code></pre>
<p>解决方案：提供工厂模式对程序扩展</p>
<pre><code>/**
    * 静态工厂
    */
public class BeanFactory &#123;
    /**
        * 通过类名来获取需要的对象
        */
    public static Object getInstance(String className)&#123;
        Object instance = null;
        try &#123;
            Class clz = Class.forName(className);
            instance = clz.newInstance();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        return instance;
    &#125;
&#125;
​
​
/**
* 使用静态工厂获取业务类对象
*/
public static void main(String[] agrs)&#123;
    UserService userService = (UserService) BeanFactory.getInstance(&quot;com.xr.service.impl.UserServiceImpl&quot;);
    userService.delete(new User());
&#125;
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong><font color=#87CEFA>总结</font></strong></h3><p>工厂模式+反射+配置文件，就是spring IOC的原理</p>
<h2 id="Spring入门-4"><a href="#Spring入门-4" class="headerlink" title="Spring入门"></a><strong><font color=#87CEFA>Spring入门</font></strong></h2><h3 id="导入Spring开发的基本包坐标"><a href="#导入Spring开发的基本包坐标" class="headerlink" title="导入Spring开发的基本包坐标"></a><strong><font color=#87CEFA>导入Spring开发的基本包坐标</font></strong></h3><pre><code>&lt;!-- 自定义版本号 --&gt;
&lt;properties&gt;
    &lt;!-- ‘spring.version’自定义的标记 --&gt;
    &lt;spring.version&gt;5.1.5.RELEASE&lt;/spring.version&gt;
&lt;/properties&gt;
&lt;dependencies&gt;
    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h3 id="创建Spring配置文件"><a href="#创建Spring配置文件" class="headerlink" title="创建Spring配置文件"></a><strong><font color=#87CEFA>创建Spring配置文件</font></strong></h3><p>名字可任意取，但是建议规范命名为：applicationContext.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;/beans&gt;
</code></pre>
<p>在Spring配置文件中配置</p>
<pre><code>&lt;!--
bean标签：用于配置对象交由Spring来创建。
默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功
​
id标识名不允许重复，默认需要类有无参构造
class：bean的全限定名称
--&gt;
&lt;bean id=&quot;userDao&quot; class=&quot;dao.impl.UserDaoImpl&quot;&gt;
&lt;/bean&gt;
​
&lt;bean id=&quot;userService&quot; class=&quot;service.impl.UserServiceImpl&quot;&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="API详解"><a href="#API详解" class="headerlink" title="API详解"></a><strong><font color=#87CEFA>API详解</font></strong></h3><p>ApplicationContext:接口，代表应用上下文，可以通过其实例获得 Spring 容器中的 Bean 对象</p>
<h3 id="API详解-1"><a href="#API详解-1" class="headerlink" title="API详解"></a><strong><font color=#87CEFA>API详解</font></strong></h3><p>ApplicationContext的实现类</p>
<pre><code>ClassPathXmlApplicationContext：它是从类的根路径下加载配置文件 推荐使用这种
AnnotationConfigApplicationContext: 当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。
</code></pre>
<h3 id="getBean-方法使用"><a href="#getBean-方法使用" class="headerlink" title="getBean()方法使用"></a><strong><font color=#87CEFA>getBean()方法使用</font></strong></h3><p>方式一</p>
<pre><code>根据Bean的id从IOC容器中获得Bean实例
UserService userService1 = (UserService) applicationContext.getBean(&quot;userService&quot;);
</code></pre>
<p>方式二</p>
<pre><code>根据类型从IOC容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错
UserService userService2 = applicationContext.getBean(UserService.class);
            
</code></pre>
<h2 id="IOC和DI"><a href="#IOC和DI" class="headerlink" title="IOC和DI"></a><strong><font color=#87CEFA>IOC和DI</font></strong></h2><p>IOC—Inversion of Control，即“控制反转”。 在Java开发中，IOC意味着将你设计好的对象交给spring完成，而不是由我们自己编写代码去new了。</p>
<p>IoC能做什么？ IOC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。 传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IOC容器后，把创建和查找依赖对象的控制权交给了spring容器，由spring容器进行注入组合对象，所以对象与对象之间是松散耦合， 这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。工厂模式+反射+配置文件，就是spring IOC的原理。</p>
<p>DI—Dependency Injection，即“依赖注入”： 组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。 依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的 平台。 应用程序需要 IOC容器来提供对象需要的外部资源</p>
<pre><code>Action依赖 Service 依赖注入
Service依赖 DAO 依赖注入
DAO层依赖 Session
        
</code></pre>
<h2 id="Spring的依赖注入"><a href="#Spring的依赖注入" class="headerlink" title="Spring的依赖注入"></a><strong><font color=#87CEFA>Spring的依赖注入</font></strong></h2><h3 id="通过set方法注入属性值"><a href="#通过set方法注入属性值" class="headerlink" title="通过set方法注入属性值"></a><strong><font color=#87CEFA>通过set方法注入属性值</font></strong></h3><pre><code>public class User &#123;
    //定义名字
    private String name;
    
    public void test() &#123;
        System.out.println(&quot;注入的姓名:&quot;+name);
    &#125;
    
    //name的set方法
    public void setName(String name) &#123;
        this.name = name;
    &#125;
&#125;
</code></pre>
<p>applicationContext.xml</p>
<pre><code>&lt;!-- id是自命名，要求是唯一的 --&gt;
&lt;bean id=&quot;user&quot; class=&quot;entity.User&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>测试</p>
<pre><code>public static void main(String[] agrs)&#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    User user = (User) context.getBean(&quot;user&quot;);
    user.test();
&#125;
</code></pre>
<h3 id="通过构造方法注入属性值"><a href="#通过构造方法注入属性值" class="headerlink" title="通过构造方法注入属性值"></a><strong><font color=#87CEFA>通过构造方法注入属性值</font></strong></h3><pre><code>public class User &#123;
</code></pre>
<p>​<br>        private String name;<br>        private Integer id;</p>
<pre><code>    public User()&#123;&#125;
    
    public User(Integer id,String name)&#123;
        this.id = id;
        this.name = name;
    &#125;
    
    public void test() &#123;
        System.out.println(&quot;注入的id:&quot;+id+&quot;,姓名:&quot;+name);
    &#125;
&#125;
</code></pre>
<p>applicationContext.xml</p>
<pre><code>&lt;bean id=&quot;user1&quot; class=&quot;entity.User&quot;&gt;
    &lt;!-- 构造方法的参数名字，类型，顺序 --&gt;
    &lt;constructor-arg name=&quot;id&quot; type=&quot;java.lang.Integer&quot; index=&quot;0&quot;&gt;
        &lt;value&gt;1&lt;/value&gt;
    &lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;name&quot; index=&quot;1&quot;&gt;
        &lt;value&gt;李四&lt;/value&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
<p>测试</p>
<pre><code>public static void main(String[] agrs)&#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    User user = (User) context.getBean(&quot;user1&quot;);
    user.test();
&#125;
</code></pre>
<h3 id="注入集合值"><a href="#注入集合值" class="headerlink" title="注入集合值"></a><strong><font color=#87CEFA>注入集合值</font></strong></h3><pre><code>//定义CollectionBean里面有list、Set、Map、Properties对象
public class CollectionBean &#123;
​
    private List&lt;String&gt; list;
    private Set&lt;String&gt; set;
    private Map&lt;String, String&gt; map;
    private Properties properties;
​
    public void setSet(Set&lt;String&gt; set) &#123;
        this.set = set;
    &#125;
​
    public void sexrist(List&lt;String&gt; list) &#123;
        this.list = list;
    &#125;
​
    public void setMap(Map&lt;String, String&gt; map) &#123;
        this.map = map;
    &#125;
​
    public void setProperties(Properties properties) &#123;
        this.properties = properties;
    &#125;
​
    @Override
    public String toString() &#123;
        return &quot;CollectionBean [list=&quot; + list + &quot;, set=&quot; + set + &quot;, map=&quot; + map
                + &quot;, properties=&quot; + properties + &quot;]&quot;;
    &#125;
&#125;
</code></pre>
<p>applicationContext.xml</p>
<pre><code>&lt;bean id=&quot;collectionBean&quot; class=&quot;entity.CollectionBean&quot;&gt;
    &lt;!-- 注入List集合 --&gt;
    &lt;property name=&quot;list&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;阿三&lt;/value&gt;
            &lt;value&gt;阿四&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
        
    &lt;!-- 注入set集合 --&gt;
    &lt;property name=&quot;set&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;杜兰特&lt;/value&gt;
            &lt;value&gt;哈登&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
        
    &lt;!-- 注入map集合 --&gt;
    &lt;property name=&quot;map&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;key1&quot; value=&quot;张三&quot;/&gt;
            &lt;entry key=&quot;key2&quot; value=&quot;李四&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;!-- 注入属性 --&gt;
    &lt;property name=&quot;properties&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;username&quot;&gt;orcl&lt;/prop&gt;
            &lt;prop key=&quot;password&quot;&gt;orcl&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>测试</p>
<pre><code>public static void main(String[] agrs)&#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    CollectionBean bean = (CollectionBean) applicationContext.getBean(&quot;collectionBean&quot;);
    System.out.println(bean);
&#125;
    依赖注入：spring中引用定义的对象
        public class UserServiceImpl implements UserService &#123;
    //去掉实例化，改用spring依赖注入
    private UserDAO userDAO;
    
    //添加userDAO的set方法
    public void setUserDAO(UserDAO userDAO) &#123;
        this.userDAO = userDAO;
    &#125;
    //......
&#125;
</code></pre>
<p>applicationContext.xml</p>
<pre><code>&lt;bean id=&quot;userService&quot; class=&quot;service.impl.UserServiceImpl&quot;&gt;
    &lt;!--name名称要和UserService中set方法名匹配，ref表示引用spring配置文件中已定义的bean id --&gt;
    &lt;property name=&quot;userDAO&quot; ref=&quot;userDAO&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>测试</p>
<pre><code>public static void main(String[] agrs)&#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    UserService userService = (UserService) context.getBean(&quot;userService&quot;);
    userService.add(new User());
&#125;
</code></pre>
<h1 id="SpringIOC-DI"><a href="#SpringIOC-DI" class="headerlink" title="SpringIOC+DI"></a><strong><font color=#87CEFA>SpringIOC+DI</font></strong></h1><p>spring是一个管理型框架，能整合众多著名的第三方框架、类库。在企业技术选型时，很多都会考虑选取的框架或技术和spring集成是否方便。</p>
<h2 id="SpringIOC-DI-1"><a href="#SpringIOC-DI-1" class="headerlink" title="SpringIOC+DI"></a><strong><font color=#87CEFA>SpringIOC+DI</font></strong></h2><p>Spring的核心<br>    IOC:（Inversesion of Control 反转控制）<br>        控制反转:将对象的创建权,交由Spring完成，不再是由我们自己编写代码去new<br>    AOP:Aspect Oriented Programming 面向切面编程 是面向对象的功能延伸。</p>
<h2 id="导入Spring开发的基本包坐标-1"><a href="#导入Spring开发的基本包坐标-1" class="headerlink" title="导入Spring开发的基本包坐标"></a><strong><font color=#87CEFA>导入Spring开发的基本包坐标</font></strong></h2><pre><code>&lt;!-- 自定义版本号 --&gt;
&lt;properties&gt;
    &lt;!-- ‘spring.version’自定义的标记 --&gt;
    &lt;spring.version&gt;5.1.5.RELEASE&lt;/spring.version&gt;
&lt;/properties&gt;
&lt;dependencies&gt;
    &lt;!-- 这个jar 文件为Spring 核心提供了大量扩展。可以找到使用Spring ApplicationContext --&gt;
    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- 这个jar文件包含Spring框架基本的核心工具类 --&gt;
    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!-- IOC容器必备jar包 --&gt;
    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h3 id="创建Spring配置文件-1"><a href="#创建Spring配置文件-1" class="headerlink" title="创建Spring配置文件"></a><strong><font color=#87CEFA>创建Spring配置文件</font></strong></h3><p>名字可任意取，但是建议规范命名为：applicationContext.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;/beans&gt;
</code></pre>
<h4 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a><strong><font color=#87CEFA>IOC</font></strong></h4><p>IOC—Inversion of Control，即“控制反转”。 在Java开发中，IOC意味着将你设计好的对象交给spring完成，而不是由我们自己编写代码去new了。</p>
<p>IoC能做什么？</p>
<pre><code>IOC 是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。 传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IOC容器后，把创建和查找依赖对象的控制权交给了spring容器，由spring容器进行注入组合对象，所以对象与对象之间是松散耦合， 这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。工厂模式+反射+配置文件，就是spring IOC的原理。
</code></pre>
<p>在Spring配置文件中配置</p>
<pre><code>&lt;!--
bean标签：用于配置对象交由Spring来创建。
默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功
​
id：标识名不允许重复
class：bean的全限定名称
--&gt;
&lt;bean id=&quot;user&quot; class=&quot;entity.User&quot;&gt;
&lt;/bean&gt;
​
​
&lt;!-- 指定构造方法创建对象 --&gt;
&lt;bean id=&quot;user1&quot; class=&quot;entity.User&quot;&gt;
    &lt;!-- 构造方法的参数名字，类型，顺序 --&gt;
    &lt;constructor-arg name=&quot;id&quot; type=&quot;java.lang.Integer&quot; index=&quot;0&quot;&gt;
        &lt;value&gt;1&lt;/value&gt;
    &lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;name&quot; index=&quot;1&quot;&gt;
        &lt;value&gt;李四&lt;/value&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
<p>给创建的对象注入值</p>
<pre><code>通过属性注入：要求属性一定要有set方法
    &lt;!-- id是自命名，要求是唯一的 --&gt;
    &lt;bean id=&quot;user&quot; class=&quot;entity.User&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
</code></pre>
<p>通过构造方法注入</p>
<pre><code>&lt;!-- 指定构造方法创建对象 --&gt;
&lt;bean id=&quot;user1&quot; class=&quot;entity.User&quot;&gt;
    &lt;!-- 构造方法的参数名字，类型，顺序 --&gt;
    &lt;constructor-arg name=&quot;id&quot; type=&quot;java.lang.Integer&quot; index=&quot;0&quot;&gt;
        &lt;value&gt;1&lt;/value&gt;
    &lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;name&quot; index=&quot;1&quot;&gt;
        &lt;value&gt;李四&lt;/value&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="给创建的对象注入其他bean"><a href="#给创建的对象注入其他bean" class="headerlink" title="给创建的对象注入其他bean"></a><strong><font color=#87CEFA>给创建的对象注入其他bean</font></strong></h4><pre><code>DI—Dependency Injection，即“依赖注入”： 组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。 依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的 平台。 应用程序需要 IOC容器来提供对象需要的外部资源
&lt;bean id=&quot;userDao&quot; class=&quot;dao.impl.UserDaoImpl&quot;&gt;

&lt;/bean&gt;
​
&lt;bean id=&quot;userService&quot; class=&quot;service.impl.UserServiceImpl&quot;&gt;
    &lt;!--name名称要和UserService中set方法名匹配，ref表示引用spring配置文件中已定义的bean id --&gt;
    &lt;property name=&quot;userDAO&quot; ref=&quot;userDAO&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong><font color=#87CEFA>测试</font></strong></h4><pre><code>public static void main(String[] agrs)&#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    UserService userService = (UserService) context.getBean(&quot;userService&quot;);
    userService.add(new User());
&#125;
springBean的生命周期
    User类中增加对应的方法
        public void start()&#123;
    System.out.println(&quot;spring中bean初始化&quot;);
&#125;
    
public void end()&#123;
    System.out.println(&quot;spring中bean销毁&quot;);
&#125;
</code></pre>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a><strong><font color=#87CEFA>配置文件</font></strong></h3><pre><code>&lt;bean id=&quot;user&quot; class=&quot;entity.User&quot; init-method=&quot;start&quot; destroy-method=&quot;end&quot;&gt;
    &lt;!-- 构造方法的参数名字，类型，顺序 --&gt;
    &lt;constructor-arg name=&quot;id&quot; type=&quot;java.lang.Integer&quot; index=&quot;0&quot;&gt;
        &lt;value&gt;1&lt;/value&gt;
    &lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;name&quot; index=&quot;1&quot;&gt;
        &lt;value&gt;李四&lt;/value&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a><strong><font color=#87CEFA>结果</font></strong></h3><p>先实例化，然后初始化，然后执行对应的方法，最后销毁</p>
<h3 id="销毁方法可以没有执行，解决方案"><a href="#销毁方法可以没有执行，解决方案" class="headerlink" title="销毁方法可以没有执行，解决方案"></a><strong><font color=#87CEFA>销毁方法可以没有执行，解决方案</font></strong></h3><pre><code>public static void main(String[] agrs)&#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    User user = (User) context.getBean(&quot;user&quot;);
    user.test();
    context.close();
&#125;
</code></pre>
<h2 id="spring中bean的scope作用域"><a href="#spring中bean的scope作用域" class="headerlink" title="spring中bean的scope作用域"></a><strong><font color=#87CEFA>spring中bean的scope作用域</font></strong></h2><h3 id="单例模式-singleton-默认"><a href="#单例模式-singleton-默认" class="headerlink" title="单例模式(singleton)-默认"></a><strong><font color=#87CEFA>单例模式(singleton)-默认</font></strong></h3><p>scope&#x3D;”singleton” 当一个bean的作用域为singleton, 那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。</p>
<pre><code>&lt;!-- bean也可以使用name定义名字，name可以重复，一般是有特殊字符的bean使用name --&gt;
&lt;bean name=&quot;user&quot; class=&quot;entity.User&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;
</code></pre>
<p>生命周期</p>
<pre><code>对象出生
    当应用加载，创建容器时，对象就被创建了。
对象活着
    只要容器在，对象一直活着。
对象死亡
    当应用卸载，销毁spring容器时，对象就被销毁了。
</code></pre>
<h3 id="多例模式-prototype"><a href="#多例模式-prototype" class="headerlink" title="多例模式(prototype)"></a><strong><font color=#87CEFA>多例模式(prototype)</font></strong></h3><p>标签中配置：scope&#x3D;”prototype” 以原型模式存在,每次getBean都new一个对象，长时间不使用时自动销毁</p>
<p>总结</p>
<pre><code>单例和多例是常用的两个 如果不指定Bean的作用域，Spring默认使用singleton作用域，singleton作用域的Bean实例一旦创建成功，可以重复使用。

prototype作用域每次getBean都new一个对象，长时间不使用时自动销毁。Java在创建实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此prototype作用域Bean的创建、销毁代价比较大。

除非必要，否则尽量避免将Bean被设置成prototype作用域。
</code></pre>
<h3 id="spring中bean的scope作用域-1"><a href="#spring中bean的scope作用域-1" class="headerlink" title="spring中bean的scope作用域"></a><strong><font color=#87CEFA>spring中bean的scope作用域</font></strong></h3><p>请求作用域(request)</p>
<pre><code>在一次HTTP请求中，一个bean定义对应一个实例；即每次HTTP请求将会有各自的bean实例， 它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。 考虑以后action的bean定义
&lt;bean id=&quot;loginAction&quot; class=&quot;com.xr.action.LoginAction&quot; scope=&quot;request&quot;/&gt;
</code></pre>
<h3 id="会话作用域-session"><a href="#会话作用域-session" class="headerlink" title="会话作用域(session)"></a><strong><font color=#87CEFA>会话作用域(session)</font></strong></h3><p>在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</p>
<h2 id="引入其他配置文件-DI"><a href="#引入其他配置文件-DI" class="headerlink" title="引入其他配置文件+DI"></a><strong><font color=#87CEFA>引入其他配置文件+DI</font></strong></h2><p>实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他 配置文件中，而在Spring主配置文件通过import标签进行加载</p>
<pre><code>&lt;import resource=&quot;applicationContext-xxx.xml&quot;/&gt;
</code></pre>
<h2 id="入门小结-DI"><a href="#入门小结-DI" class="headerlink" title="入门小结+DI"></a><strong><font color=#87CEFA>入门小结+DI</font></strong></h2><h3 id="传统程序的问题-DI"><a href="#传统程序的问题-DI" class="headerlink" title="传统程序的问题+DI"></a><strong><font color=#87CEFA>传统程序的问题+DI</font></strong></h3><p>*传统开发中分层 控制层—&gt;业务层—&gt;持久层—&gt;访问数据库</p>
<p>*在业务层调用持久层方法，要创建全局对象属性： 编写代码：UserDao userDa &#x3D; new UserDao(); 缺点：这样不利于程序扩展</p>
<p>*实际开发中我们可能使用的是面向接口编程： 编写代码：UserDao userDa &#x3D; new UserDaoImpl(); 缺点：如果要更改实现类，需要修改java源代码，这样程序耦合度高</p>
<p>*解决</p>
<pre><code>用配置文件配置实现类信息 创建静态工厂通过反射根据配置信息来创建对象
</code></pre>
<h3 id="使用Spring的IOC解决"><a href="#使用Spring的IOC解决" class="headerlink" title="使用Spring的IOC解决"></a><strong><font color=#87CEFA>使用Spring的IOC解决</font></strong></h3><p>IOC</p>
<pre><code>控制反转，Spring帮我们创建对象 实现的原理其实就是用配置文件配置类的信息，工厂通过反射根据配置信息来创建对象
</code></pre>
<h3 id="IOC和DI-1"><a href="#IOC和DI-1" class="headerlink" title="IOC和DI"></a><strong><font color=#87CEFA>IOC和DI</font></strong></h3><p>IoC—Inversion of Control，即“控制反转”，通过控制反转，把对象的创建交给了 Spring。</p>
<p>DI—Dependency Injection，即“依赖注入”，它是 Spring 框架核心 IOC 的具体实现。在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能没有依赖的情况。例如说业务层需要使用持久层，简单说就是坐等框架把持久层对象传入业务层，而不需要我们自己去获取了</p>
<h3 id="入门小结"><a href="#入门小结" class="headerlink" title="入门小结"></a><strong><font color=#87CEFA>入门小结</font></strong></h3><p>标签</p>
<pre><code>id属性:在容器中Bean实例的唯一标识，不允许重复
class属性:要实例化的Bean的全限定名
scope属性:Bean的作用范围，
常用是Singleton(默认)和
init-method属性:指定初始化方法
destroy-method属性:指定销毁方法
标签：属性注入
name属性：属性名称
value属性：注入的普通属性值
ref属性：注入的对象引用值
导入其他的Spring的分文件
</code></pre>
<h1 id="Spring的AOP"><a href="#Spring的AOP" class="headerlink" title="Spring的AOP"></a><strong><font color=#87CEFA>Spring的AOP</font></strong></h1><h2 id="什么是AOP？"><a href="#什么是AOP？" class="headerlink" title="什么是AOP？"></a><strong><font color=#87CEFA>什么是AOP？</font></strong></h2><p>AOP Aspect Oriented Programing 面向切面编程 AOP是通过动态代理实现程序功能的统一维护&#x2F;增强的一种技术。AOP是OOP（面向对象编程）的延续。简单点说就是在不影响类的原代码情况下，给对象增强功能<br>比如说，给业务层加日志，或者说给持久化操作方法加事务都可以使用AOP统一进行维护</p>
<h3 id="JAVA中的代理模式"><a href="#JAVA中的代理模式" class="headerlink" title="JAVA中的代理模式"></a><strong><font color=#87CEFA>JAVA中的代理模式</font></strong></h3><p>代理模式是常用的java设计模式之一，代理模式分为静态代理和动态代理</p>
<p>代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。</p>
<p>代理类与委托类之间通常会存在关联关系，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。</p>
<h3 id="代理增强功能案例"><a href="#代理增强功能案例" class="headerlink" title="代理增强功能案例"></a><strong><font color=#87CEFA>代理增强功能案例</font></strong></h3><p>准备工作</p>
<pre><code>//业务接口
public interface UserService &#123;
    public void add();
    public void delete();
    public void update();
    public void findAll();
&#125;
​
//业务实现类
public class UserServiceImpl implements UserService &#123;
    public void add() &#123;
        System.out.println(&quot;添加用户&quot;);
    &#125;
    public void delete() &#123;
        System.out.println(&quot;删除用户&quot;);
    &#125;
    public void update() &#123;
        System.out.println(&quot;修改用户&quot;);
    &#125;
    public void findAll() &#123;
        System.out.println(&quot;查询用户&quot;);
    &#125;
&#125;
</code></pre>
<p>静态代理</p>
<pre><code>/*
    *一个委托类，就需要一个静态代理的类，一个代理只能服务一个委托类
    */
public class UserServiceStaticProxy &#123;
    //代理中真正要干活的，还是需要原始的委托对象
    private UserService userService;
    public UserServiceStaticProxy(UserService userService)&#123;
        this.userService = userService;
    &#125;
    
    public void add() &#123;
        System.out.println(&quot;日志记录开始&quot;);
        //调用原始对象干活
        userService.add();
    &#125;
    public void delete() &#123;
        System.out.println(&quot;日志记录开始&quot;);
        //调用原始对象干活
        userService.delete();
    &#125;
    public void update() &#123;
        System.out.println(&quot;日志记录开始&quot;);
        //调用原始对象干活
        userService.update();
    &#125;
    public void findAll() &#123;
        System.out.println(&quot;日志记录开始&quot;);
        //调用原始对象干活
        userService.findAll();
    &#125;
&#125;
</code></pre>
<p>​</p>
<pre><code>/**
    * 测试使用静态代理
    */
public static void main(String[] args) &#123;
    // 静态代理的缺点：一个代理类只能服务于一个委托类，不通用
    UserServiceStaticProxy proxy = new UserServiceStaticProxy(new UserServiceImpl());
    proxy.add();
    proxy.update();
    proxy.delete();
    proxy.findAll();
&#125;
</code></pre>
<p>JDK的动态代理</p>
<pre><code>public class DynaProxy implements InvocationHandler&#123;

    private Object target;//真正干活的对象，需要代码增强的原始对象
    /**
        * 传递要被代理的目标类过来，根据目标类生成代理
        * @param target被代理的目标类
        * @return
        */
    public Object bind(Object target)&#123;
        this.target = target;//初始化
        /*参数1：loader,类加载器，类加载器将类其加载到内存。
            *参数2：Class[] interfaces 代理类需要实现的所有接口
            *参数3：InvocationHandler 处理类，接口，必须进行实现类
            */
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
    &#125;
    
    /**
        * 调用代理对象里的方法，都会调用这个invoke方法
        * 所有的方法的统一处理点
        */
    public Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable &#123;
        //调用代理类里的方法时，代理类会先进行代码处理，然后调用目标类里的对应方法完成操作
        System.out.println(&quot;日志记录开始&quot;);
        Object result = method.invoke(target, args);
        return result;
    &#125;
&#125;
​
​
/**
    *测试使用动态代理
    */
public static void main(String[] args) &#123;
    // 获得动态代理对象
    DynaProxy proxy = new DynaProxy();
    UserService userService = (UserService) proxy.bind(new UserServiceImpl());
    // 调用方法
    userService.add();
    userService.update();
    userService.delete();
    userService.findAll();
&#125;
</code></pre>
<p>Cglib动态代理</p>
<pre><code>cglib(Code Generation Library)是一个开源项目！是一个强大的，高性能，高质量的Code生成类库， 它可以在运行期扩展Java类与实现Java接口(final类不能使用cglib来代理) java中的代理都针对的都必须是实现接口的，没有实现接口的不能使用代理 cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类， 并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理
//没有实现接口的业务类
public class UserServiceImpl1 &#123;
    public void add() &#123;
        System.out.println(&quot;添加用户&quot;);
    &#125;
    public void delete() &#123;
        System.out.println(&quot;删除用户&quot;);
    &#125;
    public void update() &#123;
        System.out.println(&quot;修改用户&quot;);
    &#125;
    public void findAll() &#123;
        System.out.println(&quot;查询用户&quot;);
    &#125;
&#125;


//cglib实现代理，需要实现MethodInterceptor接口
public class CglibProxy implements MethodInterceptor &#123;
    
    private Object target;//真正干活的委托对象
    
    public Object bind(Object target)&#123;
        this.target = target;
        //cglib的核心对象
        Enhancer enhacer = new Enhancer();
        //将委托对象设置为父类
        enhacer.setSuperclass(target.getClass());
        //指定回调对象
        enhacer.setCallback(this);
        //产生子类dui
        return enhacer.create();
    &#125;


    /**
        * 原先使用java中动态代理的时候，每次调用方法都会进入到invoke方法
        * cglib动态代理时每次都会进入到intercept方法
        * 所有的方法都有了统一的处理点
        */
    public Object intercept(Object obj, Method method, Object[] args,
            MethodProxy proxy) throws Throwable &#123;
        //进行代码增强
        System.out.println(&quot;日志记录开始&quot;);
        //原先要执行的方法，在这里继续执行
        Object reslut  =proxy.invokeSuper(obj, args);
        System.out.println(&quot;日志记录结束&quot;);
        return reslut;
    &#125;
&#125;


/**
    *测试
    */
public static void main(String[] args) &#123;
    CglibProxy proxy = new CglibProxy();
    UserServiceImpl1 userService = (UserServiceImpl1) proxy.bind(new UserServiceImpl1());
    userService.add();
    userService.update();
    userService.delete();
    userService.findAll();
&#125;
</code></pre>
<h3 id="Spring中的AOP"><a href="#Spring中的AOP" class="headerlink" title="Spring中的AOP"></a><strong><font color=#87CEFA>Spring中的AOP</font></strong></h3><p>加依赖</p>
<pre><code>&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
    &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.9.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-logging&lt;/groupId&gt;
    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
    &lt;version&gt;1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>改约束</p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/aop 
    http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="spring里AOP的5种通知-增强-类型"><a href="#spring里AOP的5种通知-增强-类型" class="headerlink" title="spring里AOP的5种通知(增强)类型"></a><strong><font color=#87CEFA>spring里AOP的5种通知(增强)类型</font></strong></h3><p>spring aop通知(advice)分成五类</p>
<pre><code>前置通知(Before advice)
    在连接点前面执行，前置通知不会影响连接点的执行，除非此处抛出异常。 
正常返回通知(After returning advice)
    在连接点正常执行完成后执行，如果连接点抛出异常，则不会执行。 
异常返回通知(After throwing advice)
    在连接点抛出异常后执行。 
返回通知(After (finally) advice)
    在连接点执行完成后执行，不管是正常执行完成，还是抛出异常，都会执行返回通知中的内容。 
环绕通知(Around advice)
    环绕通知围绕在连接点前后，比如一个方法调用的前后。
        这是最强大的通知类型，能在方法调用前后自定义一些操作。
        环绕通知还需要负责决定是继续处理join point(调用ProceedingJoinPoint的proceed方法)还是中断执行。
</code></pre>
<p>自定义增强类</p>
<pre><code>public class MyAdvice &#123;
    public void before()&#123;
        System.out.println(&quot;前置通知&quot;);
    &#125;
    public void after()&#123;
        System.out.println(&quot;后置通知&quot;);
    &#125;
    
    public void afterReturn()&#123;
        System.out.println(&quot;返回通知&quot;);
    &#125;
    
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable&#123;
        System.out.println(&quot;环绕通知开始&quot;);
        //使用proceed执行方法，放行
        Object restult = joinPoint.proceed();
        System.out.println(&quot;环绕通知结束&quot;);
        return restult;
    &#125;
    
    public void afterThrow()&#123;
        System.out.println(&quot;异常通知&quot;);
    &#125;
&#125;
</code></pre>
<p>xml配置</p>
<pre><code>&lt;!-- 目标类，具体干活的业务实现类 --&gt;
&lt;bean id=&quot;userService&quot; class=&quot;service.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt;
&lt;!-- 自定义增强类，通知类，放入到spring管理 --&gt;
&lt;bean id=&quot;myAdvice&quot; class=&quot;advice.MyAdvice&quot;&gt;&lt;/bean&gt;
&lt;!-- aop配置 --&gt;
&lt;aop:config&gt;
    &lt;!-- 定义切点，只在UserServiceImpl里的add方法上加上通知 --&gt;
    &lt;aop:pointcut expression=&quot;execution(* service.impl.UserServiceImpl.save(..))&quot; id=&quot;p1&quot; /&gt;
    &lt;!-- 定义切点，com.xr.service.impl下所有类的所有方法都匹配 --&gt;
    &lt;aop:pointcut expression=&quot;execution(* service.impl.*.*(..))&quot; id=&quot;p2&quot; /&gt;
    &lt;!-- 在切面上织入通知 --&gt;
    &lt;aop:aspect ref=&quot;myAdvice&quot;&gt;
        &lt;!-- method:自定义增强类中的方法名 --&gt;
        &lt;!-- 前置通知 --&gt;
        &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;p2&quot;/&gt;
        &lt;!-- 后置通知，不管出不出异常都会执行 --&gt;
        &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;p2&quot;/&gt;
        &lt;!-- 返回值返回之后执行，出异常不执行 --&gt;
        &lt;aop:after-returning method=&quot;afterReturn&quot; pointcut-ref=&quot;p2&quot;/&gt;
        &lt;!-- 异常通知，出异常执行 --&gt;
        &lt;aop:after-throwing method=&quot;afterThrow&quot; pointcut-ref=&quot;p2&quot;/&gt;
        &lt;!-- 环绕通知 方法执行前后执行--&gt;
        &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;p2&quot; /&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt; 
    
    
</code></pre>
<p>测试</p>
<pre><code>public static void main(String[] args)&#123;
    ApplicationContext context = new                ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    //自动根据bean的名字来创建代理,直接获得bean原来上面的id名字
    UserService userService = (UserService) context.getBean(&quot;userService&quot;);
    userService.add();
&#125;
</code></pre>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong><font color=#87CEFA>概念</font></strong></h2><p>通知(Advice) 增强</p>
<pre><code>通知定义了切面是什么以及何时使用。描述了切面要完成的工作和何时需要执行这个工作。

要增加什么功能，什么时候增加，如：增加自定义的日志记录功能
</code></pre>
<p>连接点(Joinpoint)</p>
<pre><code>程序使用通知的一个时机，这些“时机”就是连接点。

例如日志增加的通知是在方法被调用时、或者方法里的异常被抛出时等等。
</code></pre>
<p>切入点(Pointcut)</p>
<pre><code>通知定义了切面要发生的故事和时间，连接点定义了是什么时候去使用通知，那么切入点就定义了“故事”发生的具体地点，例如是在UserServiceImple这个类的add方法上要加上日志增强功能
</code></pre>
<h2 id="spring中允许我们用正则表达式来指定"><a href="#spring中允许我们用正则表达式来指定" class="headerlink" title="spring中允许我们用正则表达式来指定"></a><strong><font color=#87CEFA>spring中允许我们用正则表达式来指定</font></strong></h2><p>切面(Aspect)</p>
<pre><code>切面是通知和切点的集合，通知和切点共同定义了切面的全部功能——它是什么，在何时何处完成其功能。
</code></pre>
<p>目标(Target)</p>
<pre><code>即被通知的对象，如果没有AOP,那么它的逻辑将要交叉别的事务逻辑，有了AOP之后它可以只关注自己要做的事（AOP让他做爱做的事）
</code></pre>
<p>织入(Weaving)</p>
<pre><code>把切面应用到目标对象来创建新的代理对象的过程

SpringAOP就是在运行时将通知织入切面的，原理应该是使用了JDK和Cglib的动态代理技术
</code></pre>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong><font color=#87CEFA>总结</font></strong></h2><ul>
<li>1.每个 Bean 都会被 JDK 或者 Cglib 代理。取决于是否有接口。</li>
<li>2.每个 Bean 会有多个“方法拦截器”。注意：拦截器分为两层，外层由 Spring 内核控制流程，内层拦截器是用户设置，也就是 AOP</li>
<li>3.当代理方法被调用时，先经过外层拦截器，外层拦截器根据方法的各种信息判断该方法应该执行哪些“内层拦 截器”。内层拦截器的设计就是职责连的设计。</li>
</ul>
<h1 id="Spring整合MyBatis"><a href="#Spring整合MyBatis" class="headerlink" title="Spring整合MyBatis"></a><strong><font color=#87CEFA>Spring整合MyBatis</font></strong></h1><h2 id="Spring和mybatis的整合"><a href="#Spring和mybatis的整合" class="headerlink" title="Spring和mybatis的整合"></a><strong><font color=#87CEFA>Spring和mybatis的整合</font></strong></h2><p>整合之后由管理MyBatis的SqlSessionFactory、事务和Mapper对象</p>
<p>pom.xml里的支持</p>
<pre><code>spring的jar包
    支持的是spring5.15
Mybatis的jar包
    支持3.2.7版本
Spring+mybatis的整合包
    1.3.2
Mysql的数据库驱动jar包

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
​
    &lt;groupId&gt;com.xr&lt;/groupId&gt;
    &lt;artifactId&gt;spring04_m&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;war&lt;/packaging&gt;
​
    &lt;name&gt;spring04_m Maven Webapp&lt;/name&gt;
    &lt;!-- FIXME change it to the project&#39;s website --&gt;
    &lt;url&gt;http://www.example.com&lt;/url&gt;
​
    &lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;
    &lt;spring.version&gt;5.1.5.RELEASE&lt;/spring.version&gt;
    &lt;/properties&gt;
​
    &lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.11&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
        
    &lt;!-- 3个核心包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;
​
    &lt;!--spring访问jdbc的依赖支持--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;
        
    &lt;!--mybatis的依赖--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;version&gt;3.2.7&lt;/version&gt;
    &lt;/dependency&gt;
        
    &lt;!--spring和mybatis整合的依赖支持--&gt;
    &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
        &lt;version&gt;1.3.2&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!--mysql驱动包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.47&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;/dependencies&gt;
​
    &lt;build&gt;
    &lt;finalName&gt;spring04_m&lt;/finalName&gt;
        
    &lt;!--编译资源文件 --&gt;
    &lt;resources&gt;
        &lt;resource&gt;
        &lt;directory&gt;src/main/java&lt;/directory&gt;
        &lt;includes&gt;
            &lt;include&gt;**/*.xml&lt;/include&gt;
        &lt;/includes&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
        &lt;directory&gt;src/main/resources&lt;/directory&gt;
        &lt;includes&gt;
            &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;include&gt;**/*.properties&lt;/include&gt;
        &lt;/includes&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
    
    &lt;!--Maven插件....... --&gt;
        
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<h3 id="加入配置文件"><a href="#加入配置文件" class="headerlink" title="加入配置文件"></a><strong><font color=#87CEFA>加入配置文件</font></strong></h3><h4 id="需要Spring和MyBatis的配置文件"><a href="#需要Spring和MyBatis的配置文件" class="headerlink" title="需要Spring和MyBatis的配置文件"></a><strong><font color=#87CEFA>需要Spring和MyBatis的配置文件</font></strong></h4><pre><code>db.properties:连接数据库的信息
SqlMapConfig.xml:MyBatis配置文件
applicationContext.xml:Spring配置文件
</code></pre>
<h4 id="db-properties"><a href="#db-properties" class="headerlink" title="db.properties"></a><strong><font color=#87CEFA>db.properties</font></strong></h4><pre><code>jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3306/MyBatis?CharacterEncoding=utf-8
jdbc.username=root
jdbc.password=123456
        SqlMapConfig.xml
            &lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
​
&lt;configuration&gt;
​
    &lt;!--！！！！！ 引入配置文件  environments废除,那么配置文件也不需要引入了--&gt;
    &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt;
​
    &lt;typeAliases&gt;
        &lt;package name=&quot;com.xr.pojo&quot;/&gt;
    &lt;/typeAliases&gt;
​
    &lt;!--！！！！！！ 和spring整合后 environments配置将废除 --&gt;
        &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
​
    &lt;!--Mapper也交给Spring管理 --&gt;
    &lt;mappers&gt;
        &lt;!-- &lt;mapper resource=&quot;com/xr/mapper/TeacherMapper.xml&quot; /&gt; --&gt;
        &lt;!-- 引用指定包下的所有映射文件 --&gt;
        &lt;package name=&quot;com.xr.mapper&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
        applicationContext.xml
            &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    
&lt;/beans&gt;
</code></pre>
<h4 id="Spring配置数据源"><a href="#Spring配置数据源" class="headerlink" title="Spring配置数据源"></a><strong><font color=#87CEFA>Spring配置数据源</font></strong></h4><p>连接池的作用</p>
<ul>
<li>连接池是为了提高程序性能出现的</li>
<li>事先实例化数据源，初始化部分连接资源</li>
<li>使用连接资源时从连接池中获取</li>
<li>使用完毕后将连接资源归还给连接池</li>
<li>常见的数连接池：DBCP、C3P0、BoneCP、Druid等</li>
</ul>
<p>配置数据源</p>
<pre><code>导入c3p0连接池包坐标
&lt;!-- c3p0 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;c3p0&lt;/groupId&gt;
    &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
    &lt;version&gt;0.9.1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>数据源的手动创建</p>
<pre><code>public static void main(String[] agrs)&#123;
    //创建数据源
    ComboPooledDataSource dataSource = new ComboPooledDataSource();
    //设置数据库连接参数
    dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);
    dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test?CharacterEncoding=utf8&quot;);
    dataSource.setUser(&quot;root&quot;);
    dataSource.setPassword(&quot;root&quot;);
    //获得连接对象
    Connection connection = dataSource.getConnection();
    System.out.println(connection);
&#125;
</code></pre>
<p>Spring配置数据源</p>
<pre><code>可以将DataSource的创建权交由Spring容器去完成
DataSource有无参构造方法，而Spring默认就是通过无参构造方法实例化对象的
DataSource要想使用需要通过set方法设置数据库连接信息，而Spring可以通过set方法进行字符串注入
&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
    &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/test?CharacterEncoding=utf8&quot;/&gt;
    &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>测试从容器当中获取数据源</p>
<pre><code>public static void main(String[] agrs)&#123;
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    DataSource dataSource = (DataSource)applicationContext.getBean(&quot;dataSource&quot;);
    Connection connection = dataSource.getConnection();
    System.out.println(connection);
&#125;
</code></pre>
<p>优化：抽取jdbc配置文件</p>
<pre><code>提取jdbc.properties配置文件
    jdbc.driver=com.mysql.jdbc.Driver
    jdbc.url=jdbc:mysql://localhost:3306/test?CharacterEncoding=utf8
    jdbc.username=root
    jdbc.password=root
applicationContext.xml加载jdbc.properties配置文件获得连接信息。
首先，需要引入context命名空间和约束路径：
命名空间：xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
约束路径：http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd&gt;

&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
    &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;
    &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;
    &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;
&lt;/bean&gt;
            
</code></pre>
<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a><strong><font color=#87CEFA>测试</font></strong></h2><h3 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a><strong><font color=#87CEFA>数据库表</font></strong></h3><pre><code>CREATE TABLE `account` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `name` varchar(20) DEFAULT NULL,
    `money` double DEFAULT NULL,
    PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;
</code></pre>
<h3 id="pojo"><a href="#pojo" class="headerlink" title="pojo"></a><strong><font color=#87CEFA>pojo</font></strong></h3><pre><code>/**
    * 账户的实体类
    */
public class Account &#123;
​
    private Integer id;
    private String name;
    private Double money;
​
    //set,get等方法省略
&#125;
</code></pre>
<h3 id="持久层接口"><a href="#持久层接口" class="headerlink" title="持久层接口"></a><strong><font color=#87CEFA>持久层接口</font></strong></h3><p>接口</p>
<pre><code>/**
    * 账户的持久层接口
    */
public interface AccountMapper &#123;
​
    /**
        * 更新账户
        */
    void update(Account account);
​
    /**
        * 根据id查询账户
        */
    Account findById(int id);
&#125;
</code></pre>
<p>mapper.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.xr.mapper.AccountMapper&quot;&gt;
    &lt;!--配置根据名称查询--&gt;
    &lt;select id=&quot;findById&quot; resultType=&quot;Account&quot; parameterType=&quot;Integer&quot;&gt;
        select * from account where id = #&#123;id&#125;
    &lt;/select&gt;
​
    &lt;!--配置更新--&gt;
    &lt;update id=&quot;update&quot; parameterType=&quot;account&quot;&gt;
        update account set name=#&#123;name&#125;,money=#&#123;money&#125; where id=#&#123;id&#125;
    &lt;/update&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="传统mybatis测试"><a href="#传统mybatis测试" class="headerlink" title="传统mybatis测试"></a><strong><font color=#87CEFA>传统mybatis测试</font></strong></h3><pre><code>    @Test
    public void test01() throws IOException &#123;
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;));
        SqlSession session = factory.openSession();
        AccountMapper account = session.getMapper(AccountMapper.class);
        System.out.println(account.findById(6));
    &#125;
</code></pre>
<h3 id="业务层接口及实现类"><a href="#业务层接口及实现类" class="headerlink" title="业务层接口及实现类"></a><strong><font color=#87CEFA>业务层接口及实现类</font></strong></h3><pre><code>/**
    * 账户的业务层接口
    */
public interface AccountService &#123;
    /**
        * 保存账户
        */
    void update(Account account);
​
    /**
        * 根据名称查询账户
        */
    Account findById(int name);
&#125;


/*实现类*/
public class AccountServiceImpl implements AccountService &#123;
​
    private AccountMapper accountMapper;
​
    public AccountMapper getAccountMapper() &#123;
        return accountMapper;
    &#125;
​
    public void setAccountMapper(AccountMapper accountMapper) &#123;
        this.accountMapper = accountMapper;
    &#125;
​
    public void update(Account account) &#123;
        accountMapper.update(account);
    &#125;
​
    public Account findById(int id) &#123;
        return accountMapper.findById(id);
    &#125;
&#125;
</code></pre>
<h3 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a><strong><font color=#87CEFA>Spring配置</font></strong></h3><h4 id="配置Session工厂"><a href="#配置Session工厂" class="headerlink" title="配置Session工厂"></a><strong><font color=#87CEFA>配置Session工厂</font></strong></h4><pre><code>&lt;!-- 配置mybatis里的SqlSessionFactory ， spring和MyBatis完美整合 --&gt;
&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;!-- 引用上面的数据源 --&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;!-- 加载mybatis配置文件，可不配置，但是别名那些就没有了 --&gt;
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:SqlMapConfig.xml&quot; /&gt;
    &lt;!-- 自动扫描mapping.xml文件，**表示迭代查找 ,,也可在mybatis-config.xml中单独指定xml
文件 --&gt;
    &lt;!--&lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/xr/mapper/*.xml&quot; /&gt;--&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="配置Mappe的代理对象"><a href="#配置Mappe的代理对象" class="headerlink" title="配置Mappe的代理对象"></a><strong><font color=#87CEFA>配置Mappe的代理对象</font></strong></h4><p>方式一</p>
<pre><code>在applicationContext.xml添加配置 MapperFactoryBean也是属于mybatis-spring整合包
&lt;!-- Mapper代理的方式开发方式一，配置Mapper代理对象 --&gt;
&lt;bean id=&quot;accountMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;
    &lt;!-- 配置Mapper接口 --&gt;
    &lt;property name=&quot;mapperInterface&quot; value=&quot;com.xr.mapper.AccountMapper&quot; /&gt;
    &lt;!-- 配置sqlSessionFactory --&gt;
    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p>方式二</p>
<pre><code>扫描包形式配置mapper(开发常用)
    &lt;!-- 扫描的形式，批量配置Mapper接口
    批量扫描不能取id,自动产生对应的名字：类名(首字母小写)
--&gt;
&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
    &lt;property name=&quot;basePackage&quot; value=&quot;com.xr.mapper&quot;&gt;&lt;/property&gt;
    &lt;!-- 这里需要使用 sqlSessionFactoryBeanName--&gt;
    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="配置Service层"><a href="#配置Service层" class="headerlink" title="配置Service层"></a><strong><font color=#87CEFA>配置Service层</font></strong></h4><pre><code>&lt;!--配置业务层--&gt;
&lt;bean id=&quot;accountService&quot; class=&quot;com.xr.service.impl.AccountServiceImpl&quot;&gt;
    &lt;property name=&quot;accountMapper&quot; ref=&quot;accountMapper&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="Spring整合Mybatis测试"><a href="#Spring整合Mybatis测试" class="headerlink" title="Spring整合Mybatis测试"></a><strong><font color=#87CEFA>Spring整合Mybatis测试</font></strong></h3><pre><code>@Test
public void test02() throws IOException &#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    AccountService usersService = context.getBean(AccountService.class);
    Account account = usersService.findById(6);
    System.out.println(account);
&#125;
​
@Test
public void test03() throws IOException &#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    AccountService usersService = context.getBean(AccountService.class);
    usersService.update(new Account(6,&quot;张三&quot;,200.1));
&#125;
</code></pre>
<h2 id="总结图"><a href="#总结图" class="headerlink" title="总结图"></a><strong><font color=#87CEFA>总结图</font></strong></h2><img src="/imgs/spring01.png">




<h1 id="Spring管理事务"><a href="#Spring管理事务" class="headerlink" title="Spring管理事务"></a><strong><font color=#87CEFA>Spring管理事务</font></strong></h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a><strong><font color=#87CEFA>什么是事务</font></strong></h2><pre><code>事务：保证一系列的数据库操作同时成功或同时失败。
例如：A——B转帐，对应于如下两条sql语句:
/*转出账户减钱*/
update account set money=money-100 where name=&#39;a&#39;;
/*转入账户加钱*/
update account set money=money+100 where name=&#39;b&#39;;

这两条语句的执行，要么全部成功，要么全部不成功。


事务的四大特性
    原子性
        一个事务内的操作，要么都成功，要么都失败。很经典的例子：转账，汇款和收款要成功都成功，要失败都失败。
    一致性
        指的是数据的一致性，和原子性其实是一件事情，只不过描述的角度不一样，原子性是从事务的操作的角度，一致性是从数据的角度来描述的。比如转账之前（1000,1000），如果转账100，那么数据状态应该是（900、1100），不应该出现中间状态（900,1000）或者（1000,1100）
    隔离性
        事务并发的时候。比如事务1做的动作给员工涨工资2000块，但是此时事务还没有提交，事务2去查询工资发现工资多了2000块，这就是脏读。解决方法就是建立事务之间的隔离机制。
    持久性
        事务一旦提交，事务提交，变化即生效。即使数据库服务器宕机，那么恢复之后，数据也应该是事务提交之后的状态，不应该回滚到以前了。
        
多事务并发可能出现的问题
    脏读(读到了未提交的数据 )
        财务人员今天心情不好，状态不好，误操作发起事务1给员工张三本月涨了1w块钱工资，但是还没有提交事务​ 张三发起事务2，查询当月工资，发现多了1W块钱，涨工资了，财务人员发现不对劲，把操作撤回，把涨工资的事务1给回滚了
    不可重复读（出现在修改update的时候）
        员工发起事务1查询工资，工资为1w，事务1尚未关闭，人力部门发起事务2给你涨了工资，涨工资到1.2W（update你的工资表的字段信息），并且提交了事务了。此时，事务1又再次查询自己的工资，发现工资为1.2W，原有的1w这个数据已经读不到了，这就叫做不可重复读
    幻读（幻读出现在增加insert和删除delete的时候）
        事务1查询工资表中工资为1w的员工的个数（10个员工），此时事务1还没有结束，正在这个时候，事务2，人力部门有两个新员工入职，他们的工资也是1w，人力部门通过事务2向工资表插入了两条记录，并且提交事务了，这个时候，事务1又去查询工资为1w的员工个数，发现多了两个员工（12个人），见鬼了，这种情况就叫做幻读
        
事务的隔离级别
    Read_uncommited
        读未提交 ，就好比十字路口没有红绿灯一样，效率高，但是风险也高，此时什么事务控制都没有。不要使用这种模式
    Read_commited
        读已提交 ，顾名思义，其他事务提交之后，才能读取到这个事务提交的数据，这种模式能解决脏读（因为脏读事务是没提交造成的）问题，解决不了幻读和不可重复读（因为这两个问题的产生就是insert delete update的时候提交了事务造成的）
    Repeatable_Read
        可重复读 ，可以进行数据重复读, 解决了不可重复读的问题
    serializable
        极端模式，串行化，所有的事务一个个来，不争不抢，一个事务处理完了，另外一个事务继续进行，这样不会出现并发问题。比如ATM机
        
注意
    mysql数据库默认隔离级别可重复读Repeatable_Read，oracle数据库默认级别读已提交Read_commited
    
</code></pre>
<h2 id="Spring中的事务"><a href="#Spring中的事务" class="headerlink" title="Spring中的事务"></a><strong><font color=#87CEFA>Spring中的事务</font></strong></h2><p>在数据层或者业务层保证一系列的数据库操作同时成功或同时失败。</p>
<p>不过一般我们都会在业务层开启事务，因为有的时候一个业务层可能会调用多个数据层操作，这样我们可以保证一个业务操作是在同一个事务中的。</p>
<h3 id="pom-xml加依赖"><a href="#pom-xml加依赖" class="headerlink" title="pom.xml加依赖"></a><strong><font color=#87CEFA>pom.xml加依赖</font></strong></h3><pre><code>&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;
&lt;/dependency&gt;
​
&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.9.2&lt;/version&gt;
&lt;/dependency&gt;
​
&lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-logging&lt;/groupId&gt;
    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
    &lt;version&gt;1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="applicationContext-xml加命名空间"><a href="#applicationContext-xml加命名空间" class="headerlink" title="applicationContext.xml加命名空间"></a><strong><font color=#87CEFA>applicationContext.xml加命名空间</font></strong></h3><p>要加入事务(tx)和AOP(aop)相关的命名空间和约束</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop.xsd
    http://www.springframework.org/schema/tx
    http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;
    
&lt;/beans&gt;
    
</code></pre>
<h3 id="Spring事务相关对象"><a href="#Spring事务相关对象" class="headerlink" title="Spring事务相关对象"></a><strong><font color=#87CEFA>Spring事务相关对象</font></strong></h3><p>PlatformTransactionManager 接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法。</p>
<img src="/imgs/spring02.png">
        
        
<p>注意</p>
<pre><code>PlatformTransactionManager 是接口类型，不同的 Dao 层技术则有不同的实现类，例如
    Dao 层技术是jdbc 或 mybatis 时
        org.springframework.jdbc.datasource.DataSourceTransactionManager 
    层技术是hibernate时
        org.springframework.orm.hibernate5.HibernateTransactionManager
</code></pre>
<h3 id="银行转账案例"><a href="#银行转账案例" class="headerlink" title="银行转账案例"></a><strong><font color=#87CEFA>银行转账案例</font></strong></h3><p>需求</p>
<pre><code>模拟银行转账，A账户减钱 B账户加钱
</code></pre>
<p>数据库表</p>
<pre><code>CREATE TABLE `account` (
`id` int(11) NOT NULL AUTO_INCREMENT,
`name` varchar(20) DEFAULT NULL,
`money` double DEFAULT NULL,
    PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;
        数据
            
        Mapper接口
            public interface AccountMapper &#123;
​
    @Update(&quot;update account set money=money-#&#123;money&#125; where name=#&#123;name&#125;&quot;)
    int outMoney(@Param(&quot;name&quot;)String name,@Param(&quot;money&quot;) int money);
​
    @Update(&quot;update account set money=money+#&#123;money&#125; where name=#&#123;name&#125;&quot;)
    int inMoney(@Param(&quot;name&quot;)String name,@Param(&quot;money&quot;) int money);
&#125;
</code></pre>
<p>业务层</p>
<pre><code>public class AccountServiceImpl implements AccountService &#123;
</code></pre>
<p>​<br>        private AccountMapper accountMapper;<br>    ​<br>        @Override<br>        public void transfer(String in, String out, int money) {<br>            accountMapper.inMoney(in,money);<br>            int i&#x3D;5&#x2F;0; &#x2F;&#x2F;模拟出错<br>            accountMapper.outMoney(out,money);<br>        }<br>    ​<br>        public AccountMapper getAccountMapper() {<br>            return accountMapper;<br>        }<br>    ​<br>        public void setAccountMapper(AccountMapper accountMapper) {<br>            this.accountMapper &#x3D; accountMapper;<br>        }<br>    }</p>
<p>测试</p>
<pre><code>@Test
public void test01() throws IOException &#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    AccountService accountService =(AccountService) context.getBean(&quot;accountService&quot;);
    accountService.transfer(&quot;李四&quot;,&quot;张三&quot;,100);
&#125;
</code></pre>
<h3 id="Spring事务解决转账问题"><a href="#Spring事务解决转账问题" class="headerlink" title="Spring事务解决转账问题"></a><strong><font color=#87CEFA>Spring事务解决转账问题</font></strong></h3><p>配置事务管理器对象</p>
<pre><code>&lt;!--配置事务管理器:spring针对jdbc和mybatis的事务管理类
    在配置DataSourceTransactionManager事务管理器时注入了数据库连接池，这样Spring就知道已经将数据库事务委托给了事务管理器transactionManager管理了。--&gt;
&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p>事务增强配置</p>
<pre><code>&lt;!-- 对事务管理配置增强通知--&gt;
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRED&quot;/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
</code></pre>
<p>定义切点，将事务通知和切点组合</p>
<pre><code>&lt;!-- 定义切点，将事务通知和切点组合 --&gt;
&lt;aop:config&gt;
    &lt;!-- 定义切点 --&gt;
    &lt;aop:pointcut expression=&quot;execution(* com.xr.service.*.*(..))&quot; id=&quot;mypoincut&quot;/&gt;
    &lt;!-- 切点和通知组合 --&gt;
    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;mypoincut&quot;/&gt;
&lt;/aop:config&gt;
再测试我们就发现转账同时失败了
</code></pre>
<p>标签详解</p>
<pre><code>tx:advice
    &lt;!--
        作用：
            用于配置事务的通知。
        出现位置：
            beans标签内部都可定义
        属性：
            id：为事务通知提供一个唯一标识。
            transaction-manager：为事务通知指定一个事务管理器的id引用。默认值是transactionManager。
    --&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    
tx:attribute
    &lt;!--
        作用：
            用于配置事务的属性。
        出现位置：
            要求写在&lt;tx:advice&gt;标签内部
    --&gt;
    &lt;tx:attributes&gt;
    
tx:method
    &lt;!--
        作用：
            用于配置每个需要事务支持的方法，所使用的特征。
        出现位置：
            要求写在&lt;tx:attributes&gt;标签内部
        属性：
            name：指定方法名称。支持通配符的配置方式。例如：表示所有方法 find*表示以find开头的方法。
            orad-only：指定是否为只读事务。默认值：false，表示非只读。只有查询方法可以设置为true。
            timeout：指定事务的超时时间。默认值是-1，表示永不超时。取值为正整数，以秒为单位。
            rollback-for:用于指定一个异常，当产生该异常时，事务回滚。（比如说产生检查期异常时默认是不回滚的，但是我们可以指定某个检查期异常回滚）
            no-rollback-for:用于指定一个异常，当产生该异常时，事务不回滚。和rollback-for相反。
            propagation：指定事务的传播行为。
                REQUIRED,默认值,表示必须有事务
                SUPPORTS,查询方法设置,表示有事务就支持，没有事务就以非事务
    ​
            isolation:指定事务的隔离级别。默认值是DEFAULT,表示采用数据库的默认隔离级别，不同数据库的默认隔离级别不一样，mysql为REPEATABLE READ,Oracle为READ COMMITTED。其他取值还有：READ UNCOMMITTED和SERIALIZABLE。隔离级别越高执行效率越低，反之亦然。
    --&gt;
    &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; timeout=&quot;-1&quot; isolation=&quot;&quot; rollback-for=&quot;&quot; no-rollback-for=&quot;&quot;/&gt;
    
aop:advisor

    &lt;!--
        作用：
            用于建立通知和切入点表达式的关系
        出现位置：
            要求写在&lt;aop:config&gt;标签内部
        属性：
            id:用于指定通知器的唯一标识
            advice-ref:用于指定通知的引用
            pointcut-ref:用于指定切入点表达式的引用
            pointcut:用于指定切入点表达式
            order:当配置多个advisor，用于指定执行优先级
    --&gt;
    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt1&quot; id=&quot;&quot; pointcut=&quot;&quot; order=&quot;&quot;&gt;&lt;/aop:advisor&gt;
</code></pre>
<h1 id="Spring注解开发"><a href="#Spring注解开发" class="headerlink" title="Spring注解开发"></a><strong><font color=#87CEFA>Spring注解开发</font></strong></h1><p>Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。</p>
<p>Spring原始注解</p>
<table>
<thead>
<tr>
<th align="center">注解</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">@Component</td>
<td align="center">使用在类上用于实例化Bean</td>
</tr>
<tr>
<td align="center">@Controller</td>
<td align="center">@Qualifier</td>
</tr>
<tr>
<td align="center">@Service</td>
<td align="center">使用在service层类上用于实例化Bean</td>
</tr>
<tr>
<td align="center">@Repository</td>
<td align="center">使用在Dao层类上用于实例化Bean</td>
</tr>
<tr>
<td align="center">@Autowired</td>
<td align="center">使用在字段上用于根据类型依赖注入</td>
</tr>
<tr>
<td align="center">@Qualifier</td>
<td align="center">结合@Autowired一起使用用于根据名称进行依赖注入</td>
</tr>
<tr>
<td align="center">@Resource</td>
<td align="center">相当于@Autowired+@Qualifier，按照名称进行注入</td>
</tr>
<tr>
<td align="center">@Value</td>
<td align="center">注入普通属性</td>
</tr>
<tr>
<td align="center">@Scope</td>
<td align="center">标注Bean的作用范围</td>
</tr>
<tr>
<td align="center">@PostConstruct</td>
<td align="center">使用在方法上标注该方法时Bean的初始化</td>
</tr>
<tr>
<td align="center">@PreDestroy</td>
<td align="center">使用在方法上标注该方法是Bean的销毁方法</td>
</tr>
</tbody></table>
<p>注意</p>
<pre><code>使用注解进行开发时，需要在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包下的Bean 需要进行扫描以便识别使用注解配置的类、字段和方法。
&lt;!--注解的组件扫描--&gt;
&lt;context:component-scan base-package=&quot;com.xr&quot;&gt;&lt;/context:componentscan&gt;
</code></pre>
<p>案例</p>
<pre><code>//@Component(&quot;userDao&quot;)
@Repository(&quot;userDao&quot;)
@Scope(&quot;prototype&quot;)
public class UserDaoImpl implements UserDao &#123;
    
    @Value(&quot;注入普通数据&quot;)
    private String str;
    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)
    private String driver;
    
    @Override
    public void save() &#123;
        System.out.println(&quot;save running... ...&quot;);
    &#125;
    
    
    @PostConstruct
    public void init()&#123;
        System.out.println(&quot;初始化方法....&quot;);
    &#125;
    
    @PreDestroy
    public void destroy()&#123;
        System.out.println(&quot;销毁方法.....&quot;);
    &#125;
    
&#125;
​
​
//@Component(&quot;userService&quot;)
@Service(&quot;userService&quot;)
public class UserServiceImpl implements UserService &#123;
    /*
        @Autowired
        @Qualifier(&quot;userDao&quot;)
    */
    @Resource(name=&quot;userDao&quot;)
    private UserDao userDao;
    @Override
    public void save() &#123;
        userDao.save();
    &#125;
&#125;
</code></pre>
<p>Spring新注解</p>
<table>
<thead>
<tr>
<th align="center">注解</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">@Configuration</td>
<td align="center">用于指定当前类是一个spring配置类，当创建容器时会从该类上加载注解</td>
</tr>
<tr>
<td align="center">@ComponentScan</td>
<td align="center">用于指定Spring在初始化容器时要扫描的包，作用在Spring的XML配置文件中的&lt;context:component-scan base-package&#x3D;”com.xr”&#x2F;&gt;一样</td>
</tr>
<tr>
<td align="center">@Bean</td>
<td align="center">使用在方法上，标注该方法的返回值到Spring容器中</td>
</tr>
<tr>
<td align="center">@PropertySoure</td>
<td align="center">用于 .properties 文件中的配置</td>
</tr>
<tr>
<td align="center">@MapperScan</td>
<td align="center">扫描mapper层，会帮我们创建mapper接口的代理对象</td>
</tr>
<tr>
<td align="center">@Import</td>
<td align="center">扫描mapper层，会帮我们创建mapper接口的代理对象</td>
</tr>
</tbody></table>
<p>| @Transctional | 可以用在类上或方法上，表示该类的方法或者某个方法启动事务管理 |<br>| @EnableTransactionManagement | 启用注解事务 |</p>
<p>案例</p>
<pre><code>@Configuration
@ComponentScan(&quot;com.xr.service&quot;)
@Import(&#123;DataSourceConfiguration.class,SessionFactoryConfig.class,TransactionManagerConfig.class&#125;)
@MapperScan(&quot;com.xr.mapper&quot;)
@EnableTransactionManagement
public class SpringConfiguration &#123;
    
&#125;
​
​
@PropertySource(&quot;classpath:jdbc.properties&quot;)
public class DataSourceConfiguration &#123;
    
    @Value(&quot;$&#123;driver&#125;&quot;)
    private String driver;
    @Value(&quot;$&#123;url&#125;&quot;)
    private String url;
    @Value(&quot;$&#123;uname&#125;&quot;)
    private String username;
    @Value(&quot;$&#123;pwd&#125;&quot;)
    private String password;
    
    @Bean(name=&quot;dataSource&quot;)
    public DataSource getDataSource() throws PropertyVetoException &#123;
        ComboPooledDataSource dataSource = new ComboPooledDataSource();
        dataSource.setDriverClass(driver);
        dataSource.setJdbcUrl(url);
        dataSource.setUser(username);
        dataSource.setPassword(password);
        return dataSource;
    &#125;
&#125;
​
//配置sqlSessionFactory
public class SessionFactoryConfig &#123;
​
    @Bean
    public SqlSessionFactoryBean createSqlSessionFactoryBean(DataSource dataSource)&#123;
        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        sqlSessionFactoryBean.setTypeAliasesPackage(&quot;com.xr.pojo&quot;);
        sqlSessionFactoryBean.setConfigLocation(new PathMatchingResourcePatternResolver().getResource(&quot;SqlMapConfig.xml&quot;));
        return sqlSessionFactoryBean;
    &#125;
&#125;
​
//配置TransactionManagerConfig
public class MyBatisConfig &#123;
    @Bean
    public DataSourceTransactionManager createDataSourceTransactionManager(DataSource dataSource)&#123;
        DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();
        dataSourceTransactionManager.setDataSource(dataSource);
        return dataSourceTransactionManager;
    &#125;
&#125;
​
//注册事务管理器
public class TransactionManagerConfig &#123;
    @Bean
    public DataSourceTransactionManager dataSourceTransactionManager(DataSource dataSource)&#123;
        DataSourceTransactionManager transactionManager = new
        DataSourceTransactionManager(dataSource);
        return transactionManager;
        &#125;
&#125;
</code></pre>
<p>测试</p>
<pre><code>public static void main(String[] args)&#123;
    ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfiguration.class);
    UserService userService = (UserService)applicationContext.getBean(&quot;userService&quot;);
    userService.save();
    DataSource dataSource = (DataSource)applicationContext.getBean(&quot;dataSource&quot;);
    Connection connection = dataSource.getConnection();
    System.out.println(connection);
&#125;
</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">DaiBlogger</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/02/spring/">http://example.com/2023/03/02/spring/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">DaiBlogger</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/helloWorld.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/06/springmvc/" title="springmvc"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">springmvc</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/02/maven/" title="maven"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">maven</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/helloWorld.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">DaiBlogger</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/javagogoing/javagogoing.github.io.git"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">Spring入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E5%85%A5%E9%97%A8-1"><span class="toc-number">1.1.</span> <span class="toc-text">Spring入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E5%85%A5%E9%97%A8-2"><span class="toc-number">1.2.</span> <span class="toc-text">Spring入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E5%85%A5%E9%97%A8-3"><span class="toc-number">1.3.</span> <span class="toc-text">Spring入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%B8%AD%E7%9A%84IOC%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">Spring中的IOC原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%AD%E5%88%86%E5%B1%82"><span class="toc-number">1.4.1.</span> <span class="toc-text">传统开发中分层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">面向接口编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E8%80%A6%E5%90%88"><span class="toc-number">1.4.3.</span> <span class="toc-text">解耦合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E5%85%A5%E9%97%A8-4"><span class="toc-number">1.5.</span> <span class="toc-text">Spring入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5Spring%E5%BC%80%E5%8F%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8C%85%E5%9D%90%E6%A0%87"><span class="toc-number">1.5.1.</span> <span class="toc-text">导入Spring开发的基本包坐标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BASpring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.5.2.</span> <span class="toc-text">创建Spring配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.5.3.</span> <span class="toc-text">API详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API%E8%AF%A6%E8%A7%A3-1"><span class="toc-number">1.5.4.</span> <span class="toc-text">API详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getBean-%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.5.</span> <span class="toc-text">getBean()方法使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IOC%E5%92%8CDI"><span class="toc-number">1.6.</span> <span class="toc-text">IOC和DI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-number">1.7.</span> <span class="toc-text">Spring的依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87set%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5%E5%B1%9E%E6%80%A7%E5%80%BC"><span class="toc-number">1.7.1.</span> <span class="toc-text">通过set方法注入属性值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5%E5%B1%9E%E6%80%A7%E5%80%BC"><span class="toc-number">1.7.2.</span> <span class="toc-text">通过构造方法注入属性值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5%E9%9B%86%E5%90%88%E5%80%BC"><span class="toc-number">1.7.3.</span> <span class="toc-text">注入集合值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringIOC-DI"><span class="toc-number">2.</span> <span class="toc-text">SpringIOC+DI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringIOC-DI-1"><span class="toc-number">2.1.</span> <span class="toc-text">SpringIOC+DI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5Spring%E5%BC%80%E5%8F%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8C%85%E5%9D%90%E6%A0%87-1"><span class="toc-number">2.2.</span> <span class="toc-text">导入Spring开发的基本包坐标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BASpring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">创建Spring配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IOC"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">IOC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%85%A5%E5%85%B6%E4%BB%96bean"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">给创建的对象注入其他bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.2.</span> <span class="toc-text">配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C"><span class="toc-number">2.2.3.</span> <span class="toc-text">结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E6%B2%A1%E6%9C%89%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.2.4.</span> <span class="toc-text">销毁方法可以没有执行，解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E4%B8%ADbean%E7%9A%84scope%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.3.</span> <span class="toc-text">spring中bean的scope作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-singleton-%E9%BB%98%E8%AE%A4"><span class="toc-number">2.3.1.</span> <span class="toc-text">单例模式(singleton)-默认</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%BE%8B%E6%A8%A1%E5%BC%8F-prototype"><span class="toc-number">2.3.2.</span> <span class="toc-text">多例模式(prototype)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring%E4%B8%ADbean%E7%9A%84scope%E4%BD%9C%E7%94%A8%E5%9F%9F-1"><span class="toc-number">2.3.3.</span> <span class="toc-text">spring中bean的scope作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E4%BD%9C%E7%94%A8%E5%9F%9F-session"><span class="toc-number">2.3.4.</span> <span class="toc-text">会话作用域(session)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-DI"><span class="toc-number">2.4.</span> <span class="toc-text">引入其他配置文件+DI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E5%B0%8F%E7%BB%93-DI"><span class="toc-number">2.5.</span> <span class="toc-text">入门小结+DI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98-DI"><span class="toc-number">2.5.1.</span> <span class="toc-text">传统程序的问题+DI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Spring%E7%9A%84IOC%E8%A7%A3%E5%86%B3"><span class="toc-number">2.5.2.</span> <span class="toc-text">使用Spring的IOC解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IOC%E5%92%8CDI-1"><span class="toc-number">2.5.3.</span> <span class="toc-text">IOC和DI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E5%B0%8F%E7%BB%93"><span class="toc-number">2.5.4.</span> <span class="toc-text">入门小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E7%9A%84AOP"><span class="toc-number">3.</span> <span class="toc-text">Spring的AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAOP%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">什么是AOP？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text">JAVA中的代理模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E5%A2%9E%E5%BC%BA%E5%8A%9F%E8%83%BD%E6%A1%88%E4%BE%8B"><span class="toc-number">3.1.2.</span> <span class="toc-text">代理增强功能案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%B8%AD%E7%9A%84AOP"><span class="toc-number">3.1.3.</span> <span class="toc-text">Spring中的AOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring%E9%87%8CAOP%E7%9A%845%E7%A7%8D%E9%80%9A%E7%9F%A5-%E5%A2%9E%E5%BC%BA-%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.4.</span> <span class="toc-text">spring里AOP的5种通知(增强)类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">3.2.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E4%B8%AD%E5%85%81%E8%AE%B8%E6%88%91%E4%BB%AC%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9D%A5%E6%8C%87%E5%AE%9A"><span class="toc-number">3.3.</span> <span class="toc-text">spring中允许我们用正则表达式来指定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">3.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E6%95%B4%E5%90%88MyBatis"><span class="toc-number">4.</span> <span class="toc-text">Spring整合MyBatis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E5%92%8Cmybatis%E7%9A%84%E6%95%B4%E5%90%88"><span class="toc-number">4.1.</span> <span class="toc-text">Spring和mybatis的整合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%85%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">4.1.1.</span> <span class="toc-text">加入配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E8%A6%81Spring%E5%92%8CMyBatis%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">需要Spring和MyBatis的配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#db-properties"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">db.properties</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">Spring配置数据源</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-1"><span class="toc-number">4.2.</span> <span class="toc-text">测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8"><span class="toc-number">4.2.1.</span> <span class="toc-text">数据库表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pojo"><span class="toc-number">4.2.2.</span> <span class="toc-text">pojo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%B1%82%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.2.3.</span> <span class="toc-text">持久层接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9Fmybatis%E6%B5%8B%E8%AF%95"><span class="toc-number">4.2.4.</span> <span class="toc-text">传统mybatis测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E5%B1%82%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">4.2.5.</span> <span class="toc-text">业务层接口及实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E9%85%8D%E7%BD%AE"><span class="toc-number">4.2.6.</span> <span class="toc-text">Spring配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AESession%E5%B7%A5%E5%8E%82"><span class="toc-number">4.2.6.1.</span> <span class="toc-text">配置Session工厂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEMappe%E7%9A%84%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.2.6.2.</span> <span class="toc-text">配置Mappe的代理对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEService%E5%B1%82"><span class="toc-number">4.2.6.3.</span> <span class="toc-text">配置Service层</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E6%95%B4%E5%90%88Mybatis%E6%B5%8B%E8%AF%95"><span class="toc-number">4.2.7.</span> <span class="toc-text">Spring整合Mybatis测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%9B%BE"><span class="toc-number">4.3.</span> <span class="toc-text">总结图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.</span> <span class="toc-text">Spring管理事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.1.</span> <span class="toc-text">什么是事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.2.</span> <span class="toc-text">Spring中的事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pom-xml%E5%8A%A0%E4%BE%9D%E8%B5%96"><span class="toc-number">5.2.1.</span> <span class="toc-text">pom.xml加依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#applicationContext-xml%E5%8A%A0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">5.2.2.</span> <span class="toc-text">applicationContext.xml加命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.2.3.</span> <span class="toc-text">Spring事务相关对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E8%BD%AC%E8%B4%A6%E6%A1%88%E4%BE%8B"><span class="toc-number">5.2.4.</span> <span class="toc-text">银行转账案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E8%BD%AC%E8%B4%A6%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.5.</span> <span class="toc-text">Spring事务解决转账问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="toc-number">6.</span> <span class="toc-text">Spring注解开发</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/01/Spring%E4%B8%89%E5%B1%82%E9%85%8D%E7%BD%AE/" title="Spring三层配置">Spring三层配置</a><time datetime="2023-04-01T09:14:16.000Z" title="发表于 2023-04-01 17:14:16">2023-04-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/29/Spring-Boot/" title="Spring-Boot">Spring-Boot</a><time datetime="2023-03-29T01:14:44.000Z" title="发表于 2023-03-29 09:14:44">2023-03-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/29/Docker/" title="Docker">Docker</a><time datetime="2023-03-29T01:03:44.000Z" title="发表于 2023-03-29 09:03:44">2023-03-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/22/zookeeper%E6%80%BB%E7%BB%93/" title="zookeeper总结">zookeeper总结</a><time datetime="2023-03-22T12:27:32.000Z" title="发表于 2023-03-22 20:27:32">2023-03-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/20/Dubbo%E6%80%BB%E7%BB%93/" title="Dubbo总结">Dubbo总结</a><time datetime="2023-03-20T05:12:22.000Z" title="发表于 2023-03-20 13:12:22">2023-03-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By DaiBlogger</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>